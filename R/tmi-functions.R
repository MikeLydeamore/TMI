#' Simulate population according to linearised SIS model
#' 
#' @param lambda The force of infection
#' @param gamma The rate of recovery (inverse of infectious period)
#' @param max_time Maximum length of time (days) for which to simulate individuals for
#' @param num_individuals Number of individuals to seperately simulate
#' 
#' @return List where each element contains the time series information of an individual.
#' 
#' @examples 
#' simulations <- simulateLinearisedSIS(lambda=1/60, gamma=1/20, num_individuals=400)
simulateLinearedSIS <- function(lambda, gamma, max_time=365, num_individuals=1)
{
  simulations <- lapply(1:num_individuals, function(i) { 
    l <- runLinearisedSISModel(lambda, gamma, max_time)
    l$id <- i
    return (l)})
  
  return (simulations)
}

#' Convert model simulations to panel data
#' 
#' @param simulations A list where each element contains the time series information for a single individual, and also the ID of that individual.
#' @param sampling_times A list where each element contain the times to sample that specific individual.
#' 
#' @return A data frame containing the panel data for the entire population.
#' 
#' @examples
#' simulations <- simulateLinearedSIS(lambda=1/60, gamma=1/20, num_individuals=100)
#' sampling_times <- lapply(1:num_individuals, function(i) { rep(x=1, times=365)})
#' panel_data <- convertSimulationsToPanelData(simulations, sampling_times)
convertSimulationsToPanelData <- function(simulations, sampling_times)
{
  num_individuals <- length(simulations)
  max_time <- max(sapply(1:num_individuals, function(i) { max(simulations[[i]]$t)}))
  panel_data <- lapply(1:num_individuals, function(i) {
    t <- 0
    counter <- 1
    simulation <- simulations[[i]]
    sampling_time <- sampling_times[[i]]
    observation_times <- c()
    state <- c()
    while (t < max_time & counter < length(sampling_time))
    {
      observation_times <- c(observation_times, t)
      idx <- tail(which(simulation$t <= t), n=1)
      if (simulation$S[idx] == 1)
        state <- c(state, 1)
      else
        state <- c(state, 2)
      
      t <- t + sampling_time[counter]
      counter <- counter+1
    }
    
    return (data.frame("state"=state, "t"=observation_times, "id"=i))
  })
  
  panel_data <- do.call(rbind, panel_data)
  return (panel_data)
}

#' Plot marginal posteriors from fitted data.
#' 
#' Plots the marginal posteriors for both lambda and gamma, as well as 95% CIs (solid lines) and 99% CIs (dashed lines)
#' 
#' @param stan_fit The fitted result from stan
#' @param lambda True value of lambda (-1 if true value is unknown)
#' @param gamma True value of gamma (-1 if true value is unknown)
plot_fits <- function(stan_fit, lambda_ = -1, gamma_ = -1)
{
  df <- as.data.frame(stan_fit) %>% select(lambda, gamma) %>% melt(id.vars=c())
  cis <- group_by(df, variable) %>% summarise(lower95 = quantile(value, 0.025), upper95 = quantile(value, 0.975),
                                              lower99 = quantile(value, 0.005), upper99 = quantile(value, 0.995))
  
  int_frame <- data.frame("variable"=c("lambda","gamma"), "value"=c(lambda_, gamma_))
  
  p <- ggplot() + geom_density(aes(x=value), data=df) + facet_wrap(~variable, scales = "free") + 
    labs(x="Parameter Value", y="Density") +
    geom_vline(aes(xintercept=lower95), data=cis, colour="red") + geom_vline(aes(xintercept=upper95), data=cis, colour="red") +
    geom_vline(aes(xintercept=lower99), data=cis, colour="red", linetype="dashed") + geom_vline(aes(xintercept=upper99), data=cis, colour="red", linetype="dashed")
  if (lambda_ == -1 | gamma_ == -1)
  {
    return (p)
    
  }
  
  return (p + geom_vline(aes(xintercept=value), data = int_frame, colour="blue")) 
}

#' Set up panel data for fitting
#' 
#' @param panel_data The input panel data
#' 
#' @return A list containing the data for use for fitting, of class "tmidata".
setupData <- function(panel_data)
{
  num_individuals <- length(unique(panel_data$id))
  num_obs <- sapply(1:num_individuals, function(i) { nrow(filter(panel_data, id == i))})
  times <- lapply(1:num_individuals, function(i) {
    t <- filter(panel_data, id == i)$age_seen
    padding <- max(num_obs) - length(t)
    return (c(t, rep(x=0, times = padding)))
  })
  times <- do.call(rbind, times)
  S <- lapply(unique(panel_data$id), function(i) { 
    f <- as.numeric(filter(panel_data, id == i)$skin_sores)-1
    padding <- max(num_obs) - length(f)
    return (c(f, rep(x=0, times=padding)))
    
  })
  S <- do.call(rbind, S)
  
  stan_inputs = list("S"=S, "times"=times, "num_individuals"=num_individuals, "num_obs"=num_obs)
  
  class(stan_inputs) <- "tmidata"
  
  return (stan_inputs)
}

#' Fit model using stan
#' 
#' @param data Panel data to fit for, of class "tmidata" (such as that generated by the setupData function)
#' @param iterations Number of iterations to run each chain for
#' @param model Model code for stan. The default model is that for the two-state Markov chain.
#' 
#' @return The stan fit.
fit_stan <- function(data, iterations = 10000, model = tmi_model)
{
  if (class(data) != "tmidata")
    stop("Argument data must have class tmidata")
  
  fit <- sampling(model_code = tmi_model, data = data, iter=iterations, pars=c("lambda","gamma"), ...)
  
  return (fit)
}